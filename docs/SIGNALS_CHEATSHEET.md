# Gu√≠a de Signals: Todo lo que necesitas saber

> **üí° Nota importante:** Spoonkit Signals est√° construido sobre [`@preact/signals-core`](https://www.npmjs.com/package/@preact/signals-core), una librer√≠a de gesti√≥n de estado de alto rendimiento. Esta gu√≠a documenta la API de Spoonkit (`state()`, `calc()`, `monitor()`, `stateObject()`, `stateArray()`), que envuelve las primitivas de Preact en una API propia para evitar dependencias directas.

## üéØ ¬øQu√© son los Signals?

Los **signals** son contenedores reactivos para valores que pueden cambiar con el tiempo. Son como variables inteligentes que autom√°ticamente notifican y actualizan todo lo que depende de ellas cuando su valor cambia.

El sistema de signals de Spoonkit est√° dise√±ado para ser:

- ‚ö° **Performante**: Optimiza autom√°ticamente las actualizaciones para mantener tu app r√°pida
- üéØ **Lazy por defecto**: Solo actualiza lo que realmente est√° siendo observado
- üß† **Inteligente**: Salta autom√°ticamente signals que nadie est√° escuchando
- üîÑ **Reactivo**: Cuando cambias un valor, todas las dependencias se actualizan solas

**Pi√©nsalo as√≠:**

- **Variable normal**: Cambias el valor ‚Üí tienes que actualizar todo manualmente üòì
- **Signal**: Cambias el valor ‚Üí todo se actualiza solo ‚ú®

### ¬øC√≥mo funcionan?

Los signals funcionan mediante un **sistema de suscripciones autom√°ticas**:

1. Cuando lees un signal dentro de un `calc()` o `monitor()`, autom√°ticamente te suscribes a √©l
2. Cuando el signal cambia, notifica a todos sus suscriptores
3. Las actualizaciones se propagan de forma eficiente, ejecutando solo lo m√≠nimo necesario
4. El sistema de reactividad es completamente transparente: no necesitas declarar dependencias manualmente

---

## üì¶ Los 3 tipos de Signals b√°sicos

### 1. `state()` - El Signal b√°sico

Es el signal m√°s simple y fundamental. Guarda un valor que puede cambiar con el tiempo y notifica autom√°ticamente a sus suscriptores cuando lo modificas.

```typescript
import { state } from "./lib/signals/State";

// Crear un state
const nombre = state("Ana");

// Leer el valor (activa reactividad)
console.log(nombre.get()); // "Ana"

// Cambiar el valor (notifica a todos los suscriptores)
nombre.set("Luis");
console.log(nombre.get()); // "Luis"

// Leer sin activar reactividad (peek = "espiar")
console.log(nombre.peek()); // "Luis"

// Tambi√©n puedes crear un state vinculado a otro signal
// (se sincronizar√°n autom√°ticamente, veremos esto m√°s adelante)
const otroNombre = state(nombre);
```

**¬øCu√°ndo usar `state()`?**

- Para valores simples que pueden cambiar: strings, n√∫meros, booleanos, objetos, arrays
- Cuando necesitas guardar y actualizar datos reactivamente
- Para inputs de formularios, contadores, flags de carga, configuraciones
- Como fuente de verdad de la que derivan otros valores

**üí° Caracter√≠sticas clave:**

- **Escritura directa**: Usas `set()` para cambiar el valor de forma expl√≠cita
- **Actualizaciones s√≠ncronas**: Cuando haces `set()`, todos los dependientes se actualizan inmediatamente
- **Consistencia garantizada**: El estado de tu app siempre es consistente despu√©s de un `set()`
- **Trackeo autom√°tico**: No necesitas declarar manualmente qu√© depende de qu√©
- **Vinculable**: Puede sincronizarse autom√°ticamente con otros signals (detallado m√°s adelante)
- **Tipado fuerte**: TypeScript infiere autom√°ticamente el tipo del valor

---

### 2. `calc()` - El Signal calculado

Es un signal derivado que combina valores de otros signals. Se recalcula autom√°ticamente cuando cambian sus dependencias, pero solo si alguien lo est√° observando (es **lazy**).

```typescript
import { state } from "./lib/signals/State";
import { calc } from "./lib/signals/Calc";

const precio = state(100);
const descuento = state(0.2); // 20%

// El calc detecta autom√°ticamente que depende de precio y descuento
const precioFinal = calc(() => {
  const p = precio.get();
  const d = descuento.get();
  return p * (1 - d);
});

console.log(precioFinal.get()); // 80

// Si cambias el precio, el calc se recalcula autom√°ticamente
precio.set(200);
console.log(precioFinal.get()); // 160

// Si cambias el descuento, tambi√©n se recalcula
descuento.set(0.5); // 50%
console.log(precioFinal.get()); // 100
```

**Ejemplo de dependencias din√°micas:**

```typescript
const modo = state<"simple" | "avanzado">("simple");
const valorA = state(10);
const valorB = state(20);
const valorC = state(30);

// Las dependencias cambian seg√∫n el modo
const resultado = calc(() => {
  if (modo.get() === "simple") {
    return valorA.get(); // Solo depende de valorA
  } else {
    return valorB.get() + valorC.get(); // Depende de valorB y valorC
  }
});

console.log(resultado.get()); // 10

modo.set("avanzado");
console.log(resultado.get()); // 50 (20 + 30)

// Ahora valorA ya no afecta al resultado
valorA.set(100);
console.log(resultado.get()); // 50 (sin cambios)
```

**¬øCu√°ndo usar `calc()`?**

- Para valores derivados de otros signals: c√°lculos, transformaciones, validaciones
- Cuando tienes una f√≥rmula o c√°lculo que depende de otros valores reactivos
- Para transformar datos de forma reactiva manteniendo todo sincronizado
- Para valores de solo lectura que se mantienen actualizados autom√°ticamente
- Para optimizar rendimiento con cache inteligente de resultados

**üí° Caracter√≠sticas clave:**

- **Solo lectura**: No puedes hacer `precioFinal.set(150)`, solo cambia cuando cambian sus dependencias
- **Lazy evaluation**: Solo se ejecuta cuando alguien lee su valor con `get()`, no antes
- **Cache inteligente**: Almacena el resultado y solo recalcula cuando alguna dependencia cambia
- **Detecci√≥n autom√°tica**: Detecta sus dependencias sin que las declares manualmente
- **Dependencias din√°micas**: Las dependencias pueden cambiar seg√∫n el flujo de ejecuci√≥n (if/else, loops)
- **Optimizaci√≥n autom√°tica**: Si nadie lo observa, ni siquiera se actualiza
- **Encadenable**: Puedes crear calcs que dependan de otros calcs para c√°lculos complejos

---

### 3. `monitor()` - El Efecto reactivo

Es un efecto que se ejecuta autom√°ticamente cada vez que cambian los signals que lee. **A diferencia de `calc()`**, no devuelve un valor derivado ni es lazy: se ejecuta **inmediatamente** al crearlo y luego cada vez que cambian sus dependencias. Su prop√≥sito es ejecutar **efectos secundarios** (side effects), no calcular valores.

```typescript
import { state } from "./lib/signals/State";
import { monitor } from "./lib/signals/Monitor";

const contador = state(0);

// Se ejecuta inmediatamente y cada vez que contador cambia
const dispose = monitor(() => {
  console.log(`El contador ahora vale: ${contador.get()}`);
});
// ‚Üí Se ejecuta inmediatamente: "El contador ahora vale: 0"

contador.set(1);
// ‚Üí Se ejecuta autom√°ticamente: "El contador ahora vale: 1"

contador.set(5);
// ‚Üí Se ejecuta autom√°ticamente: "El contador ahora vale: 5"

// Cuando ya no lo necesites, limpia el efecto
dispose();
```

**¬øCu√°ndo usar `monitor()`?**

- Para sincronizar con localStorage, sessionStorage, cookies
- Para hacer llamadas a APIs cuando algo cambia
- Para actualizar el DOM manualmente o integrar con librer√≠as externas
- Para logging, debugging, analytics o m√©tricas
- Para cualquier "efecto secundario" (side effect) que deba ocurrir al cambiar el estado
- Para conectar el mundo reactivo con el mundo exterior (APIs, almacenamiento, etc.)

**üí° Caracter√≠sticas clave:**

- **Ejecuci√≥n inmediata**: Se ejecuta en cuanto lo creas, no espera a que lo lean (a diferencia de `calc()` que es lazy)
- **Para side effects**: Dise√±ado para efectos secundarios, no para calcular valores (usa `calc()` para eso)
- **Auto-tracking**: Detecta autom√°ticamente qu√© signals lee dentro de la funci√≥n
- **Limpieza manual**: Debes llamar a `dispose()` cuando termines para evitar fugas de memoria
- **Actualizaciones s√≠ncronas**: Cuando cambia una dependencia, se ejecuta inmediatamente
- **Sin valor de retorno**: No devuelve un valor reactivo (solo la funci√≥n `dispose` para limpieza)

**üéØ Ejemplo con funci√≥n de cleanup:**

```typescript
import { state } from "./lib/signals/State";
import { monitor } from "./lib/signals/Monitor";

const userId = state(1);

// Monitor con funci√≥n de limpieza
const dispose = monitor(() => {
  const id = userId.get();
  console.log(`Cargando datos del usuario ${id}`);

  // Esta funci√≥n de cleanup se ejecuta en DOS momentos:
  // 1. ANTES de que el monitor se vuelva a ejecutar (cuando cambia una dependencia)
  // 2. Cuando llamas a dispose() para detener el monitor completamente
  return () => {
    console.log(`Limpiando datos del usuario ${id}`);
  };
});

userId.set(2);
// ‚Üí "Limpiando datos del usuario 1" (cleanup del monitor anterior)
// ‚Üí "Cargando datos del usuario 2" (nueva ejecuci√≥n del monitor)

userId.set(3);
// ‚Üí "Limpiando datos del usuario 2" (cleanup del monitor anterior)
// ‚Üí "Cargando datos del usuario 3" (nueva ejecuci√≥n del monitor)

// Al terminar de usar el monitor
dispose();
// ‚Üí "Limpiando datos del usuario 3" (cleanup final)
```

**‚ö†Ô∏è Importante sobre cleanup:**
La funci√≥n de cleanup se ejecuta autom√°ticamente **antes de cada re-ejecuci√≥n** del monitor, no solo cuando haces `dispose()`. Esto es crucial para limpiar recursos (timers, subscripciones, event listeners) antes de crearlos de nuevo, evitando fugas de memoria.

---

## üîë Conceptos Clave de Reactividad

### Lazy por defecto

Los signals son **lazy** (perezosos): las actualizaciones de los `calc()` solo ocurren si alguien est√° escuchando. Un `calc()` no se ejecuta hasta que alguien lee su valor con `get()`. Si nadie observa un signal, las actualizaciones no se propagan.

```typescript
const a = state(1);
const b = state(2);

// Este calc NO se ejecuta todav√≠a (nadie lo est√° leyendo)
const suma = calc(() => {
  console.log("Calculando suma");
  return a.get() + b.get();
});

// AHORA se ejecuta porque lo le√≠mos
console.log(suma.get()); // ‚Üí "Calculando suma", 3

a.set(10);
// NO se recalcula porque nadie est√° leyendo suma en este momento

console.log(suma.get()); // ‚Üí "Calculando suma", 12
```

**Nota:** Los `monitor()` NO son lazy. Se ejecutan inmediatamente y cada vez que cambian sus dependencias, sin importar si alguien los observa.

### Actualizaciones s√≠ncronas

Cuando cambias un signal con `set()`, todas las actualizaciones ocurren **s√≠ncronamente** (inmediatamente). Tu app siempre est√° en un estado consistente.

```typescript
const nombre = state("Ana");
const apellido = state("Garc√≠a");
const nombreCompleto = calc(() => `${nombre.get()} ${apellido.get()}`);

monitor(() => {
  console.log(nombreCompleto.get());
});
// ‚Üí "Ana Garc√≠a"

nombre.set("Luis");
// ‚Üí Se ejecuta INMEDIATAMENTE: "Luis Garc√≠a"
```

### `get()` vs `peek()`

- **`get()`**: Lee el valor **Y se suscribe** a los cambios (activa la reactividad)
- **`peek()`**: Lee el valor **SIN suscribirse** (no activa la reactividad)

```typescript
const a = state(5);
const b = state(10);

// Este calc SOLO se suscribe a 'a', no a 'b'
const resultado = calc(() => {
  const valorA = a.get();   // ‚úÖ Reactivo: se suscribe
  const valorB = b.peek();  // ‚ùå No reactivo: solo lee
  return valorA * valorB;
});

b.set(20); // resultado NO se recalcula
a.set(10); // resultado S√ç se recalcula
```

**¬øCu√°ndo usar `peek()`?**

- Para logging o debugging sin crear dependencias
- Para evitar bucles infinitos en monitors
- Para leer un valor "auxiliar" que no debe disparar rec√°lculos
- Para comparar valores sin suscribirse (ej: "¬øcambi√≥ realmente?")

---

## üß© Signals Compuestos

### `stateObject()` - Objeto reactivo

Agrupa varios signals en un objeto reactivo donde cada propiedad mantiene su propia reactividad individual.

**Perfecto para:** Modelos de entidades, formularios complejos, estado estructurado con m√∫ltiples campos

```typescript
import { state } from "./lib/signals/State";
import { stateObject } from "./lib/signals/stateObject";

const usuario = stateObject({
  nombre: state("Ana"),
  edad: state(25),
  email: state("ana@example.com"),
});

// Obtener todo el objeto (devuelve una copia para evitar mutaciones)
console.log(usuario.get());
// { nombre: "Ana", edad: 25, email: "ana@example.com" }

// Acceder a un campo individual como signal
console.log(usuario.nombre.get()); // "Ana"

// Cambiar un campo individual
usuario.nombre.set("Carlos");

// Actualizaci√≥n parcial: solo cambiar algunos campos
usuario.set({
  nombre: "Luis",
  edad: 30,
  // email no cambia
});

console.log(usuario.get());
// { nombre: "Luis", edad: 30, email: "ana@example.com" }

// Peek para leer sin activar reactividad
console.log(usuario.peek());
```

**Ejemplo con objetos anidados:**

```typescript
import { state } from "./lib/signals/State";
import { stateObject } from "./lib/signals/stateObject";
import { stateArray } from "./lib/signals/stateArray";

// Modelo complejo con stateObject anidado y stateArray
const producto = stateObject({
  id: state("P123"),
  nombre: state("Laptop"),
  precio: state(999),
  tags: stateArray(() => state<string>()),
  // StateObject anidado para informaci√≥n del vendedor
  vendedor: stateObject({
    nombre: state("Tech Store"),
    rating: state(4.5),
  }),
});

// Inicializar con datos completos
producto.set({
  id: "P123",
  nombre: "Laptop",
  precio: 999,
  tags: ["electronics", "computers"],
  vendedor: { nombre: "Tech Store", rating: 4.5 },
});

// Acceder a propiedades anidadas
console.log(producto.vendedor.nombre.get()); // "Tech Store"
console.log(producto.vendedor.rating.get()); // 4.5

// Modificar solo una propiedad del objeto anidado
producto.vendedor.rating.set(4.8);

// Agregar un tag al array
producto.tags.push("featured");
console.log(producto.tags.get()); // ["electronics", "computers", "featured"]

// Actualizaci√≥n parcial del objeto anidado
producto.set({
  vendedor: { rating: 5.0 }, // Solo actualiza el rating del vendedor
});

console.log(producto.vendedor.get());
// { nombre: "Tech Store", rating: 5.0 }
```

**üí° Ventajas:**

- **Reactividad granular**: Cada campo es un signal independiente con su propia reactividad
- **Acceso directo**: Accede a cada propiedad como `obj.campo.get()` sin pasar por el objeto completo
- **Actualizaci√≥n parcial**: El m√©todo `set()` acepta objetos parciales, solo actualiza lo que le pasas
- **Inmutabilidad en get()**: Devuelve una copia del objeto para evitar mutaciones accidentales
- **Anidamiento**: Puedes anidar `stateObject` y `stateArray` para crear estructuras complejas
- **Combinable**: Se integra perfectamente con State y StateArray para crear modelos complejos
- **Tipado fuerte**: TypeScript mantiene los tipos de cada propiedad

---

### `stateArray()` - Array reactivo

Crea un array donde cada elemento es un signal independiente. La caracter√≠stica clave es que **reutiliza signals** inteligentemente: cuando actualizas el array con `set()`, mantiene los signals existentes y solo crea nuevos para elementos adicionales. Esto optimiza enormemente el rendimiento en listas grandes.

**Perfecto para:** Listas din√°micas, colecciones de datos, datos tabulares

```typescript
import { state } from "./lib/signals/State";
import { stateArray } from "./lib/signals/stateArray";

// Crear un array (necesita una funci√≥n factory para crear nuevos signals)
const numeros = stateArray(() => state<number>(0));

// INICIALIZACI√ìN
numeros.set([1, 2, 3]);
console.log(numeros.get()); // [1, 2, 3]

// AGREGAR ELEMENTOS
numeros.push(4);
numeros.push(5);
console.log(numeros.get()); // [1, 2, 3, 4, 5]

// QUITAR ELEMENTOS
const ultimo = numeros.pop();
console.log(ultimo); // 5
console.log(numeros.get()); // [1, 2, 3, 4]

// LIMPIAR TODO
numeros.clear();
console.log(numeros.get()); // []

// Volvemos a llenar para los siguientes ejemplos
numeros.set([10, 20, 30, 40]);

// LONGITUD (reactiva)
const longitud = numeros.length();
console.log(longitud.get()); // 4

// ACCEDER A UN ELEMENTO (devuelve el signal)
const primerNumero = numeros.at(0);
console.log(primerNumero?.get()); // 10

// Modificar ese elemento espec√≠fico
primerNumero?.set(100);
console.log(numeros.get()); // [100, 20, 30, 40]

// BUSCAR UN ELEMENTO (devuelve el signal, no el valor)
const encontrado = numeros.find((valor) => valor > 25);
console.log(encontrado?.get()); // 30

// VERIFICAR CONDICIONES
// some: ¬øAlguno cumple la condici√≥n? (devuelve Calc<boolean>)
const tieneGrandes = numeros.some((valor) => valor > 50);
console.log(tieneGrandes.get()); // true (porque 100 > 50)

// every: ¬øTodos cumplen la condici√≥n? (devuelve Calc<boolean>)
const todosMayoresACero = numeros.every((valor) => valor > 0);
console.log(todosMayoresACero.get()); // true

// MAP: Transformar cada elemento (devuelve StateArray)
// La funci√≥n recibe el VALOR y debe devolver un signal
const dobles = numeros.map((valor) => state(valor * 2));
console.log(dobles.get()); // [200, 40, 60, 80]

// FILTER: Filtrar elementos (devuelve StateArray)
const mayoresDe30 = numeros.filter((valor) => valor > 30);
console.log(mayoresDe30.get()); // [100, 40]

// REDUCE: Reducir a un valor (devuelve Calc)
const suma = numeros.reduce((total, valor) => total + valor, 0);
console.log(suma.get()); // 190 (100 + 20 + 30 + 40)

// JOIN: Unir en un string (devuelve Calc<string>)
const texto = numeros.map((n) => state(n.toString())).join(", ");
console.log(texto.get()); // "100, 20, 30, 40"

// OBTENER ARRAY DE SIGNALS (para uso avanzado)
const signals = numeros.toArray();
console.log(signals.length); // 4
console.log(signals[0].get()); // 100
```

**Ejemplo con objetos:**

```typescript
const usuarios = stateArray(() => 
  stateObject({
    nombre: state(""),
    edad: state(0),
  })
);

usuarios.set([
  { nombre: "Ana", edad: 25 },
  { nombre: "Luis", edad: 30 },
  { nombre: "Mar√≠a", edad: 22 },
]);

// Acceder y modificar un usuario espec√≠fico (at devuelve el signal)
const primerUsuario = usuarios.at(0);
primerUsuario?.set({ nombre: "Ana Mar√≠a", edad: 26 });

// Tambi√©n puedes modificar solo un campo del stateObject
primerUsuario?.nombre.set("Ana Mar√≠a");
primerUsuario?.edad.set(26);

// Filtrar usuarios mayores de 25 (filter recibe el valor)
const mayores = usuarios.filter((usuario) => usuario.edad > 25);
console.log(mayores.get()); 
// [{ nombre: "Ana Mar√≠a", edad: 26 }, { nombre: "Luis", edad: 30 }]

// Map: transformar a un array de nombres (map recibe el valor, devuelve signal)
const nombres = usuarios.map((usuario) => state(usuario.nombre));
console.log(nombres.get()); // ["Ana Mar√≠a", "Luis", "Mar√≠a"]

// Buscar un usuario (find recibe el valor, devuelve signal)
const encontrado = usuarios.find((usuario) => usuario.edad > 25);
console.log(encontrado?.get()); // { nombre: "Ana Mar√≠a", edad: 26 }

// Transformar a√±adiendo m√°s propiedades con stateObject
const usuariosConEstado = usuarios.map((usuario) =>
  stateObject({
    nombre: state(usuario.nombre),
    edad: state(usuario.edad),
    activo: state(true),
  })
);
```

**‚ö° Reutilizaci√≥n eficiente de signals:**

```typescript
const items = stateArray(() => state(0));

// Primera carga: crea 3 signals internos
items.set([1, 2, 3]);
// Internamente: [signal(1), signal(2), signal(3)]

// Segunda carga: reutiliza los 3 signals existentes y crea 2 nuevos
items.set([10, 20, 30, 40, 50]);
// Internamente: [signal(10), signal(20), signal(30), signal(40), signal(50)]
// Los primeros 3 signals se reutilizaron (solo cambi√≥ su valor)
// Solo se crearon 2 signals nuevos para 40 y 50

// Esto es MUCHO m√°s eficiente que recrear 5 signals desde cero
```

**‚ö†Ô∏è Importante sobre `map()`:**
La funci√≥n de transformaci√≥n que pasas a `map()` recibe el **valor** (no el signal) y **debe devolver un signal** (`state()`, `stateObject()`, o `stateArray()`). Esto mantiene la reactividad en el array transformado.

```typescript
// ‚úÖ CORRECTO: map recibe el valor, devuelve state
const dobles = numeros.map((valor) => state(valor * 2));

// ‚úÖ CORRECTO: map puede devolver stateObject
const conMetadata = usuarios.map((usuario) =>
  stateObject({
    datos: state(usuario),
    activo: state(true),
  })
);

// ‚ùå INCORRECTO: devuelve valor plano (no es reactivo)
const dobles = numeros.map((valor) => valor * 2);
```

**üí° Ventajas:**

- **Reutilizaci√≥n eficiente**: Al hacer `set()`, reutiliza signals existentes actualizando su valor, solo crea nuevos signals para elementos adicionales
- **Reactividad por elemento**: Cada elemento del array es un signal independiente con su propia reactividad
- **API familiar**: M√©todos como `map`, `filter`, `push`, `pop`, `reduce`, `join` que ya conoces
- **M√©todos reactivos**: `map`, `filter`, `reduce`, `join`, `some`, `every`, `length` devuelven valores reactivos (Calc o StateArray)
- **Acceso directo a signals**: Los m√©todos `at()` y `find()` devuelven el signal completo para modificarlo
- **Rendimiento optimizado**: Especialmente eficiente con listas grandes que cambian frecuentemente

---

## üîó Vinculaci√≥n de Signals

Los signals de Spoonkit tienen una caracter√≠stica √∫nica: **se pueden vincular entre s√≠** para crear sincronizaci√≥n autom√°tica. Cuando vinculas signals, los cambios se propagan autom√°ticamente sin necesidad de c√≥digo manual.

**¬øC√≥mo funciona?** Internamente crea `monitor()` (efectos reactivos) que observan cambios en un signal y actualizan el otro autom√°ticamente.

### Vincular State a State (bidireccional)

Cuando vinculas un state a otro state con `state(otroState)`, se crea una **sincronizaci√≥n bidireccional**: los cambios fluyen en ambas direcciones.

```typescript
import { state } from "./lib/signals/State";

const inputValue = state("Hola");
const displayValue = state(inputValue); // Vinculaci√≥n bidireccional

console.log(displayValue.get()); // "Hola"

// Si cambias inputValue, displayValue se actualiza autom√°ticamente
inputValue.set("Mundo");
console.log(displayValue.get()); // "Mundo"

// Si cambias displayValue, inputValue tambi√©n se actualiza
displayValue.set("Adi√≥s");
console.log(inputValue.get()); // "Adi√≥s"
console.log(displayValue.get()); // "Adi√≥s"
```

### Vincular State a Calc (unidireccional)

Cuando vinculas un state a un calc con `state(unCalc)`, se crea una **sincronizaci√≥n unidireccional**: el state sigue autom√°ticamente al calc.

```typescript
import { state } from "./lib/signals/State";
import { calc } from "./lib/signals/Calc";

const precio = state(100);
const descuento = state(0.2);
const precioFinal = calc(() => precio.get() * (1 - descuento.get()));

// displayPrice sigue autom√°ticamente a precioFinal
const displayPrice = state(precioFinal);

console.log(displayPrice.get()); // 80

precio.set(200);
console.log(displayPrice.get()); // 160 (se actualiz√≥ solo!)
```

**‚ö†Ô∏è Advertencias importantes:**

1. **Nueva vinculaci√≥n reemplaza la anterior**: Si vuelves a vincular un state con `set(otroSignal)`, la vinculaci√≥n anterior se limpia autom√°ticamente.
   
   ```typescript
   const a = state(1);
   const b = state(2);
   const c = state(a); // c vinculado a a
   
   c.set(b); // Ahora c est√° vinculado a b, la vinculaci√≥n con a se elimin√≥
   ```

2. **Valor directo NO rompe la vinculaci√≥n**: Si haces `set()` con un valor directo despu√©s de vincular, el valor se actualiza pero los monitors de vinculaci√≥n siguen activos (pueden generar comportamiento inesperado).
   
   ```typescript
   const a = state(10);
   const b = state(a); // Vinculados
   
   b.set(20); // Cambia el valor, pero los monitors siguen activos
   // Si cambias 'a' despu√©s, 'b' volver√° a sincronizarse con 'a'
   ```

3. **Vinculaci√≥n bidireccional usa recursos**: Crea dos monitors (uno en cada direcci√≥n). Si tienes muchas vinculaciones, considera el impacto en rendimiento.

---

## üé® Ejemplos Pr√°cticos Completos

TODO

## ü§î Preguntas Frecuentes

### ¬øCu√°ndo uso `get()` vs `peek()`?

- **`get()`**: Usa esto el 99% del tiempo. Lee el valor Y se suscribe a cambios (activa reactividad)
- **`peek()`**: Solo cuando NO quieres suscribirte. Lee el valor SIN activar reactividad

```typescript
const a = state(5);
const b = state(10);

// Este calc solo se reejecuta cuando 'a' cambia, no cuando 'b' cambia
const resultado = calc(() => {
  const valorA = a.get(); // ‚úÖ Reactivo: se suscribe
  const valorB = b.peek(); // ‚ùå No reactivo: solo lee
  return valorA * valorB;
});

b.set(20); // resultado NO se recalcula
a.set(10); // resultado S√ç se recalcula
```

### ¬øPuedo modificar un `calc()`?

**No.** Los `calc()` son de **solo lectura**. Solo cambian cuando cambian sus dependencias.

```typescript
const suma = calc(() => a.get() + b.get());
suma.set(100); // ‚ùå ERROR! No puedes hacer esto

// Solo puedes cambiar sus dependencias
a.set(50); // Esto S√ç actualiza suma
```

### ¬øC√≥mo limpio un `monitor()`?

Guarda la funci√≥n `dispose` que devuelve y ll√°mala cuando termines. Esto es importante para evitar **fugas de memoria**.

```typescript
const cleanup = monitor(() => {
  console.log(contador.get());
});

// Cuando ya no lo necesites
cleanup();
```

### ¬øQu√© significa que los signals son "lazy"?

**Lazy** significa que las actualizaciones solo ocurren si alguien est√° observando. Un `calc()` no se ejecuta hasta que alguien lee su valor. Si nadie observa un signal, las actualizaciones no se propagan.

```typescript
const a = state(1);
const b = state(2);

// Este calc NO se ejecuta todav√≠a
const suma = calc(() => a.get() + b.get());

a.set(10); // suma todav√≠a NO se recalcula (nadie lo est√° leyendo)

// AHORA se ejecuta porque lo le√≠mos
console.log(suma.get()); // 12
```

Esta optimizaci√≥n autom√°tica hace que tu app sea m√°s r√°pida sin que tengas que pensar en ello.

### ¬øC√≥mo evito actualizaciones innecesarias?

El sistema de signals optimiza autom√°ticamente las actualizaciones para evitar ejecuciones innecesarias:

1. **Solo actualiza lo m√≠nimo necesario**: No re-ejecuta calcs o monitors que no cambiaron
2. **Detecci√≥n de cambios**: Si asignas el mismo valor, no notifica a los suscriptores
3. **Lazy evaluation**: Solo ejecuta lo que realmente se est√° usando

```typescript
const nombre = state("Ana");

monitor(() => {
  console.log(nombre.get());
});
// ‚Üí "Ana"

nombre.set("Ana"); // ‚ùå No se ejecuta el monitor (mismo valor)
nombre.set("Luis"); // ‚úÖ Se ejecuta el monitor (valor diferente)
```

---

## üìö Resumen R√°pido

| Tipo            | Para qu√© sirve                     | Se puede modificar | Ejemplo                                       |
| --------------- | ---------------------------------- | ------------------ | --------------------------------------------- |
| `state()`       | Valor simple reactivo              | ‚úÖ S√≠              | `const nombre = state("Ana")`                 |
| `calc()`        | Valor calculado autom√°tico         | ‚ùå No              | `const total = calc(() => a.get() + b.get())` |
| `monitor()`     | Ejecutar c√≥digo cuando algo cambia | N/A                | `monitor(() => console.log(x.get()))`         |
| `stateObject()` | Objeto con m√∫ltiples signals       | ‚úÖ S√≠              | `stateObject({ x: state(1), y: state(2) })`   |
| `stateArray()`  | Array de signals                   | ‚úÖ S√≠              | `stateArray(() => state({ id: 0 }))`          |

---

## üí° Tips y Mejores Pr√°cticas

### 1. Empieza simple

Comienza con `state()` para todo. Cuando veas patrones repetitivos, considera usar `calc()` o estructuras compuestas.

```typescript
// ‚úÖ Bien para empezar
const nombre = state("Ana");
const apellido = state("Garc√≠a");

// ‚úÖ Mejor cuando veas el patr√≥n
const nombreCompleto = calc(() => `${nombre.get()} ${apellido.get()}`);
```

### 2. Aprovecha la evaluaci√≥n lazy

Recuerda que `calc()` es lazy. Solo se ejecuta cuando alguien lee su valor. Usa esto a tu favor para optimizar.

```typescript
// Este calc solo se ejecuta si alguien lo lee
const calculoComplejo = calc(() => {
  // Operaci√≥n costosa
  return datos.get().reduce(...);
});

// Si nunca lo lees, nunca se ejecuta
```

### 3. Usa `monitor()` correctamente

Los `monitor()` son para **efectos secundarios** (side effects). No los uses para derivar estado, usa `calc()` para eso.

```typescript
// ‚ùå Mal: Derivar estado con monitor
const total = state(0);
monitor(() => {
  total.set(precio.get() * cantidad.get());
});

// ‚úÖ Bien: Derivar estado con calc
const total = calc(() => precio.get() * cantidad.get());
```

### 4. Limpia tus monitors

Siempre limpia los `monitor()` cuando ya no los necesites para evitar fugas de memoria.

```typescript
useEffect(() => {
  const cleanup = monitor(() => {
    console.log(contador.get());
  });

  // Limpia cuando el componente se desmonte
  return cleanup;
}, []);
```

### 5. Conf√≠a en la detecci√≥n autom√°tica

No necesitas declarar dependencias manualmente. Los signals detectan autom√°ticamente qu√© observar.

```typescript
// ‚úÖ Las dependencias se detectan autom√°ticamente
const resultado = calc(() => {
  if (condicion.get()) {
    return a.get() + b.get();
  }
  return c.get();
});
// Se suscribe a: condicion, a, b, y c (seg√∫n la rama que se ejecute)
```

### 6. Aprovecha la consistencia garantizada

Las actualizaciones son s√≠ncronas. Tu app siempre est√° en un estado consistente.

```typescript
const a = state(1);
const b = state(2);
const suma = calc(() => a.get() + b.get());

a.set(10);
// Inmediatamente despu√©s, suma ya est√° actualizada
console.log(suma.get()); // 12 (siempre consistente)
```

### 8. Usa `peek()` sabiamente

Solo usa `peek()` cuando realmente necesites leer sin suscribirte. Casos t√≠picos: logging, debugging, o evitar bucles infinitos.

```typescript
// ‚úÖ Buen uso de peek: evitar bucle infinito
monitor(() => {
  const newValue = input.get();
  const oldValue = output.peek(); // No queremos suscribirnos a output

  if (newValue !== oldValue) {
    output.set(newValue);
  }
});
```

---

## üéì Recursos Adicionales

- **[@preact/signals-core](https://www.npmjs.com/package/@preact/signals-core)**: La librer√≠a base sobre la que est√° construido los signals de Spoonkit
- **[Preact Signals Blog Post](https://preactjs.com/blog/introducing-signals/)**: Art√≠culo que explica la filosof√≠a y problemas que resuelven los signals
- **C√≥digo fuente**: Revisa los archivos `State.ts`, `Calc.ts`, `Monitor.ts`, `stateObject.ts` y `stateArray.ts` para entender c√≥mo funciona internamente

---

## üöÄ ¬°Siguiente paso!

¬°Ahora ya sabes todo lo necesario para usar signals como un pro! La mejor forma de aprender es practicando:

1. Empieza con un formulario simple usando `stateObject()`
2. Agrega validaciones reactivas con `calc()`
3. Sincroniza con localStorage usando `monitor()`
4. Crea listas din√°micas con `stateArray()`

**Recuerda:** Los signals est√°n optimizados autom√°ticamente. Conc√©ntrate en escribir c√≥digo claro y deja que `@preact/signals-core` se encargue del rendimiento. ‚ú®
